import MagicString from "magic-string";
import type {
  IRComponent,
  IRNode,
  IRBinding,
  IRHandler,
  IRHandlerStatement,
  IRStateVariable,
} from "../ir/types.js";

const FIELD_TYPES: Record<string, "string" | "number" | "boolean" | "color"> = {
  text: "string",
  width: "number",
  height: "number",
  fontSize: "number",
  opacity: "number",
  color: "string",
  visible: "boolean",
  focusable: "boolean",
  uri: "string",
};

/**
 * Build BrightScript output using MagicString.
 * Internally uses MagicString so we can add source map generation later
 * via ms.generateMap() without changing the emitter internals.
 */
export function emitBrightScript(component: IRComponent): string {
  const hasState = component.state && component.state.length > 0;

  if (!hasState) {
    return emitV1(component);
  }

  const lines: string[] = [];
  buildV2(component, lines);

  // Use MagicString as the output buffer â€” ready for .generateMap() later
  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function buildV2(component: IRComponent, lines: string[]): void {
  const hasBindings = component.bindings && component.bindings.length > 0;
  const hasEvents = component.events && component.events.length > 0;
  const hasHandlers = component.handlers && component.handlers.length > 0;

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.2");
  lines.push("");

  emitInit(component, lines);
  lines.push("");

  if (hasBindings) {
    emitUpdate(component, lines);
    lines.push("");
  }

  if (hasEvents) {
    emitOnKeyEvent(component, lines);
    lines.push("");
  }

  if (hasHandlers) {
    emitHandlers(component, lines);
  }

  while (lines[lines.length - 1] === "") {
    lines.pop();
  }
}

function emitV1(component: IRComponent): string {
  const lines: string[] = [];

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.1");
  lines.push("");
  lines.push("function init()");

  const nodeRefs = collectDynamicNodeRefs(component.children);

  if (nodeRefs.length > 0) {
    lines.push("  ' node refs");
    for (const ref of nodeRefs) {
      lines.push(`  m.${ref.varName} = m.top.findNode("${ref.id}")`);
    }
    lines.push("");

    lines.push("  ' dynamic properties");
    for (const ref of nodeRefs) {
      for (const prop of ref.properties) {
        const bsValue = toBrightScriptValue(prop.name, prop.value);
        lines.push(`  m.${ref.varName}.${prop.name} = ${bsValue}`);
      }
    }
  }

  lines.push("end function");

  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function emitInit(component: IRComponent, lines: string[]): void {
  lines.push("function init()");

  const refNodeIds = new Set<string>();
  if (component.bindings) {
    for (const b of component.bindings) {
      refNodeIds.add(b.nodeId);
    }
  }
  if (component.events) {
    for (const e of component.events) {
      refNodeIds.add(e.nodeId);
    }
  }

  if (refNodeIds.size > 0) {
    for (const nodeId of refNodeIds) {
      const varName = sanitizeVarName(nodeId);
      lines.push(`  m.${varName} = m.top.findNode("${nodeId}")`);
    }
  }

  if (component.state && component.state.length > 0) {
    const stateEntries = component.state.map((sv) => {
      return `${sv.name}: ${formatStateInitialValue(sv)}`;
    });
    lines.push(`  m.state = { ${stateEntries.join(", ")}, dirty: {} }`);
  }

  if (component.autofocusNodeId) {
    const varName = sanitizeVarName(component.autofocusNodeId);
    lines.push(`  m.${varName}.setFocus(true)`);
  }

  if (component.bindings && component.bindings.length > 0) {
    lines.push("  m_update()");
  }

  lines.push("end function");
}

function emitUpdate(component: IRComponent, lines: string[]): void {
  if (!component.bindings || !component.state) return;

  lines.push("function m_update()");

  const groups = new Map<string, IRBinding[]>();
  for (const binding of component.bindings) {
    const key = [...binding.dependencies].sort().join(",");
    const group = groups.get(key) ?? [];
    group.push(binding);
    groups.set(key, group);
  }

  const stateVarMap = new Map<string, IRStateVariable>();
  for (const sv of component.state) {
    stateVarMap.set(sv.name, sv);
  }

  for (const [, bindings] of groups) {
    const deps = bindings[0]!.dependencies;
    const condition = deps
      .map((d) => `m.state.dirty.${d}`)
      .join(" or ");

    lines.push(`  if ${condition} then`);

    for (const binding of bindings) {
      const varName = sanitizeVarName(binding.nodeId);
      const value = emitBindingValue(binding, stateVarMap);
      lines.push(`    m.${varName}.${binding.property} = ${value}`);
    }

    lines.push("  end if");
  }

  lines.push("  m.state.dirty = {}");
  lines.push("end function");
}

function emitBindingValue(
  binding: IRBinding,
  stateVarMap: Map<string, IRStateVariable>,
): string {
  if (binding.textParts) {
    const parts = binding.textParts.map((part) => {
      if (part.type === "static") {
        return `"${escapeString(part.value)}"`;
      } else {
        const sv = stateVarMap.get(part.value);
        return coerceToString(part.value, sv);
      }
    });
    return parts.join(" + ");
  }

  const sv = stateVarMap.get(binding.stateVar);
  const targetType = FIELD_TYPES[binding.property] ?? "string";

  return coerceValue(binding.stateVar, sv, targetType);
}

function coerceToString(varName: string, sv: IRStateVariable | undefined): string {
  if (!sv || sv.type === "string") {
    return `m.state.${varName}`;
  }
  if (sv.type === "number") {
    return `Str(m.state.${varName}).Trim()`;
  }
  if (sv.type === "boolean") {
    return `Str(m.state.${varName})`;
  }
  return `m.state.${varName}`;
}

function coerceValue(
  varName: string,
  sv: IRStateVariable | undefined,
  targetType: "string" | "number" | "boolean" | "color",
): string {
  const sourceType = sv?.type ?? "string";

  if (targetType === "string" || targetType === "color") {
    if (sourceType === "number") {
      return `Str(m.state.${varName}).Trim()`;
    }
    if (sourceType === "boolean") {
      return `Str(m.state.${varName})`;
    }
    return `m.state.${varName}`;
  }

  return `m.state.${varName}`;
}

function emitOnKeyEvent(component: IRComponent, lines: string[]): void {
  if (!component.events) return;

  const selectEvents = component.events.filter((e) => e.eventType === "select");
  if (selectEvents.length === 0) return;

  lines.push("function onKeyEvent(key as String, press as Boolean) as Boolean");
  lines.push("  if press then");
  lines.push('    if key = "OK" then');
  lines.push("      focused = m.top.focusedChild");
  lines.push("      if focused <> invalid then");

  for (let i = 0; i < selectEvents.length; i++) {
    const event = selectEvents[i]!;
    const prefix = i === 0 ? "        if" : "        else if";
    lines.push(`${prefix} focused.id = "${event.nodeId}" then`);
    lines.push(`          ${event.handlerName}()`);
    lines.push("          return true");
  }

  lines.push("        end if");
  lines.push("      end if");
  lines.push("    end if");
  lines.push("  end if");
  lines.push("  return false");
  lines.push("end function");
}

function emitHandlers(component: IRComponent, lines: string[]): void {
  if (!component.handlers) return;

  for (let i = 0; i < component.handlers.length; i++) {
    const handler = component.handlers[i]!;
    if (i > 0) lines.push("");
    emitHandler(handler, lines);
  }
}

function emitHandler(handler: IRHandler, lines: string[]): void {
  lines.push(`function ${handler.name}()`);

  for (const stmt of handler.statements) {
    lines.push(`  ${emitStatement(stmt)}`);
  }

  for (const varName of handler.mutatedVariables) {
    lines.push(`  m.state.dirty.${varName} = true`);
  }

  lines.push("  m_update()");
  lines.push("end function");
}

function emitStatement(stmt: IRHandlerStatement): string {
  switch (stmt.type) {
    case "increment":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + 1`;
    case "decrement":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - 1`;
    case "assign-literal":
      return `m.state.${stmt.variable} = ${formatLiteral(stmt.value)}`;
    case "assign-negate":
      return `m.state.${stmt.variable} = not m.state.${stmt.variable}`;
    case "assign-add":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + ${formatLiteral(stmt.operand)}`;
    case "assign-sub":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - ${formatLiteral(stmt.operand)}`;
  }
}

function formatLiteral(value: string): string {
  const num = Number(value);
  if (!isNaN(num) && value !== "" && value !== "true" && value !== "false") {
    return value;
  }
  if (value === "true" || value === "false") {
    return value;
  }
  return `"${escapeString(value)}"`;
}

function formatStateInitialValue(sv: IRStateVariable): string {
  if (sv.type === "number") return sv.initialValue;
  if (sv.type === "boolean") return sv.initialValue;
  return `"${escapeString(sv.initialValue)}"`;
}

function escapeString(s: string): string {
  return s.replace(/"/g, '""');
}

interface NodeRef {
  id: string;
  varName: string;
  properties: Array<{ name: string; value: string }>;
}

function collectDynamicNodeRefs(nodes: IRNode[]): NodeRef[] {
  const refs: NodeRef[] = [];

  function traverse(node: IRNode): void {
    const dynamicProps = node.properties.filter((p) => p.dynamic);
    if (dynamicProps.length > 0) {
      refs.push({
        id: node.id,
        varName: sanitizeVarName(node.id),
        properties: dynamicProps,
      });
    }
    for (const child of node.children) {
      traverse(child);
    }
  }

  for (const node of nodes) {
    traverse(node);
  }

  return refs;
}

function sanitizeVarName(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

export function toBrightScriptValue(fieldName: string, value: string): string {
  if (value === "true" || value === "false") {
    return value;
  }

  if (value.startsWith("0x")) {
    return `"${value}"`;
  }

  const numericFields = new Set([
    "width",
    "height",
    "fontSize",
    "opacity",
  ]);
  if (numericFields.has(fieldName)) {
    const num = parseFloat(value);
    if (!isNaN(num)) {
      return String(num);
    }
  }

  return `"${value.replace(/"/g, '""')}"`;
}
