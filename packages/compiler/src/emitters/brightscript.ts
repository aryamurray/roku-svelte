import MagicString from "magic-string";
import type {
  IRComponent,
  IRNode,
  IRBinding,
  IRHandler,
  IRHandlerStatement,
  IRStateVariable,
  IRItemComponent,
  IREachBlock,
  IRAsyncHandler,
} from "../ir/types.js";

const FIELD_TYPES: Record<string, "string" | "number" | "boolean" | "color" | "array"> = {
  text: "string",
  width: "number",
  height: "number",
  fontSize: "number",
  opacity: "number",
  color: "string",
  visible: "boolean",
  focusable: "boolean",
  uri: "string",
  translation: "array",
  rotation: "number",
  scale: "array",
  horizAlign: "string",
  vertAlign: "string",
  wrap: "boolean",
  maxLines: "number",
  lineSpacing: "number",
  font: "string",
  letterSpacing: "number",
};

/**
 * Build BrightScript output using MagicString.
 * Internally uses MagicString so we can add source map generation later
 * via ms.generateMap() without changing the emitter internals.
 */
export function emitBrightScript(component: IRComponent): string {
  const hasState = component.state && component.state.length > 0;

  if (!hasState) {
    return emitV1(component);
  }

  const lines: string[] = [];
  buildV2(component, lines);

  // Use MagicString as the output buffer — ready for .generateMap() later
  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

export function emitItemComponentBrightScript(itemComp: IRItemComponent): string {
  const lines: string[] = [];

  lines.push(`' ${itemComp.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");

  // init() — find all nodes
  lines.push("function init()");
  const nodeIds = new Set<string>();
  for (const binding of itemComp.fieldBindings) {
    nodeIds.add(binding.nodeId);
  }
  for (const nodeId of nodeIds) {
    const varName = sanitizeVarName(nodeId);
    lines.push(`  m.${varName} = m.top.findNode("${nodeId}")`);
  }
  lines.push("end function");
  lines.push("");

  // onItemContentChanged()
  lines.push("function onItemContentChanged()");
  lines.push("  itemContent = m.top.itemContent");
  lines.push("  if itemContent <> invalid then");

  for (const binding of itemComp.fieldBindings) {
    const varName = sanitizeVarName(binding.nodeId);
    if (binding.textParts && binding.textParts.length > 1) {
      // Mixed text concatenation
      const parts = binding.textParts.map((part) => {
        if (part.type === "static") {
          return `"${escapeString(part.value)}"`;
        } else {
          return `itemContent.${part.value}`;
        }
      });
      lines.push(`    m.${varName}.${binding.property} = ${parts.join(" + ")}`);
    } else {
      // Simple field binding
      lines.push(`    m.${varName}.${binding.property} = itemContent.${binding.field}`);
    }
  }

  lines.push("  end if");
  lines.push("end function");

  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function buildV2(component: IRComponent, lines: string[]): void {
  const hasBindings = component.bindings && component.bindings.length > 0;
  const hasEvents = component.events && component.events.length > 0;
  const hasHandlers = component.handlers && component.handlers.length > 0;
  const hasEachBlocks = component.eachBlocks && component.eachBlocks.length > 0;

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");

  emitInit(component, lines);
  lines.push("");

  if (hasBindings || hasEachBlocks) {
    emitUpdate(component, lines);
    lines.push("");
  }

  if (hasEvents) {
    emitOnKeyEvent(component, lines);
    lines.push("");
  }

  if (hasHandlers) {
    emitHandlers(component, lines);
  }

  if (component.extractedCallbacks && component.extractedCallbacks.length > 0) {
    emitExtractedCallbacks(component, lines);
  }

  if (component.props && component.props.length > 0) {
    emitPropObserver(component, lines);
  }

  // onDestroy lifecycle
  if (component.onDestroyHandler) {
    lines.push("");
    lines.push("sub onDestroy_handler()");
    emitStatements(component.onDestroyHandler.statements, lines, 2);
    lines.push("end sub");
  }

  // Two-way binding observers
  if (component.twoWayBindings && component.twoWayBindings.length > 0) {
    emitTwoWayObservers(component, lines);
  }

  // Async handlers
  if (component.asyncHandlers && component.asyncHandlers.length > 0) {
    emitAsyncHandlers(component, lines);
  }

  emitFetchCallbacks(component, lines);

  while (lines[lines.length - 1] === "") {
    lines.pop();
  }
}

function emitV1(component: IRComponent): string {
  const lines: string[] = [];

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");
  lines.push("function init()");

  const nodeRefs = collectDynamicNodeRefs(component.children);

  if (nodeRefs.length > 0) {
    lines.push("  ' node refs");
    for (const ref of nodeRefs) {
      lines.push(`  m.${ref.varName} = m.top.findNode("${ref.id}")`);
    }
    lines.push("");

    lines.push("  ' dynamic properties");
    for (const ref of nodeRefs) {
      for (const prop of ref.properties) {
        const bsValue = toBrightScriptValue(prop.name, prop.value);
        lines.push(`  m.${ref.varName}.${prop.name} = ${bsValue}`);
      }
    }
  }

  lines.push("end function");

  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function emitInit(component: IRComponent, lines: string[]): void {
  lines.push("function init()");

  const refNodeIds = new Set<string>();
  if (component.bindings) {
    for (const b of component.bindings) {
      refNodeIds.add(b.nodeId);
    }
  }
  if (component.events) {
    for (const e of component.events) {
      refNodeIds.add(e.nodeId);
    }
  }
  // Also add MarkupList node refs for eachBlocks
  if (component.eachBlocks) {
    for (const eb of component.eachBlocks) {
      refNodeIds.add(eb.listNodeId);
    }
  }
  // Also add two-way binding node refs
  if (component.twoWayBindings) {
    for (const twb of component.twoWayBindings) {
      refNodeIds.add(twb.nodeId);
    }
  }

  if (refNodeIds.size > 0) {
    for (const nodeId of refNodeIds) {
      const varName = sanitizeVarName(nodeId);
      lines.push(`  m.${varName} = m.top.findNode("${nodeId}")`);
    }
  }

  if (component.state && component.state.length > 0) {
    const stateEntries = component.state.map((sv) => {
      return `${sv.name}: ${formatStateInitialValue(sv)}`;
    });
    const dirtyEntries = component.state.map((sv) => `${sv.name}: true`);
    lines.push(`  m.state = { ${stateEntries.join(", ")}, dirty: { ${dirtyEntries.join(", ")} } }`);
  }

  // Read initial prop values from m.top
  if (component.props && component.props.length > 0) {
    for (const prop of component.props) {
      lines.push(`  m.state.${prop.name} = m.top.${prop.name}`);
    }
  }

  if (component.autofocusNodeId) {
    const varName = sanitizeVarName(component.autofocusNodeId);
    lines.push(`  m.${varName}.setFocus(true)`);
  }

  // Fetch calls via runtime
  if (component.state) {
    for (const sv of component.state) {
      if (sv.fetchCall) {
        const urlArg = sv.fetchCall.urlIsLiteral ? `"${sv.fetchCall.url}"` : sv.fetchCall.url;
        const optionsArg = sv.fetchCall.optionsSource ?? "{}";
        lines.push(`  m.fetchTask_${sv.name} = fetch(${urlArg}, ${optionsArg})`);
        lines.push(`  m.fetchTask_${sv.name}.observeField("response", "on_${sv.name}_loaded")`);
      }
    }
  }

  const hasBindings = component.bindings && component.bindings.length > 0;
  const hasEachBlocks = component.eachBlocks && component.eachBlocks.length > 0;
  if (hasBindings || hasEachBlocks) {
    lines.push("  m_update()");
  }

  // Two-way binding observers
  if (component.twoWayBindings && component.twoWayBindings.length > 0) {
    for (const twb of component.twoWayBindings) {
      const varName = sanitizeVarName(twb.nodeId);
      lines.push(`  m.${varName}.observeField("text", "on_${varName}_changed")`);
    }
  }

  // onMount lifecycle — emit body inline at end of init()
  if (component.onMountHandler) {
    emitStatements(component.onMountHandler.statements, lines, 2);
    for (const v of component.onMountHandler.mutatedVariables) {
      lines.push(`  m.state.dirty.${v} = true`);
    }
    if (component.onMountHandler.mutatedVariables.length > 0) {
      lines.push("  m_update()");
    }
  }

  lines.push("end function");
}

function emitUpdate(component: IRComponent, lines: string[]): void {
  if (!component.state) return;

  lines.push("function m_update()");

  const stateVarMap = new Map<string, IRStateVariable>();
  for (const sv of component.state) {
    stateVarMap.set(sv.name, sv);
  }

  // Emit derived state recomputation (before bindings so they see fresh values)
  for (const sv of component.state) {
    if (sv.derivedFrom) {
      const deps = sv.derivedFrom.dependencies;
      if (deps.length > 0) {
        const condition = deps.map((d) => `m.state.dirty.${d}`).join(" or ");
        lines.push(`  if ${condition} then`);
        if (sv.derivedFrom.preamble) {
          for (const line of sv.derivedFrom.preamble) {
            lines.push(`    ${line}`);
          }
        }
        lines.push(`    m.state.${sv.name} = ${sv.derivedFrom.brsExpression}`);
        lines.push(`    m.state.dirty.${sv.name} = true`);
        lines.push("  end if");
      }
    }
  }

  // Emit binding updates
  if (component.bindings && component.bindings.length > 0) {
    const groups = new Map<string, IRBinding[]>();
    for (const binding of component.bindings) {
      const key = [...binding.dependencies].sort().join(",");
      const group = groups.get(key) ?? [];
      group.push(binding);
      groups.set(key, group);
    }

    for (const [, bindings] of groups) {
      const deps = bindings[0]!.dependencies;
      const condition = deps
        .map((d) => `m.state.dirty.${d}`)
        .join(" or ");

      lines.push(`  if ${condition} then`);

      for (const binding of bindings) {
        const varName = sanitizeVarName(binding.nodeId);
        const value = emitBindingValue(binding, stateVarMap);
        lines.push(`    m.${varName}.${binding.property} = ${value}`);
      }

      lines.push("  end if");
    }
  }

  // Emit ContentNode creation for eachBlocks
  if (component.eachBlocks && component.eachBlocks.length > 0) {
    for (const eachBlock of component.eachBlocks) {
      emitContentNodeCreation(eachBlock, stateVarMap, lines);
    }
  }

  lines.push("  m.state.dirty = {}");
  lines.push("end function");
}

function emitContentNodeCreation(
  eachBlock: IREachBlock,
  stateVarMap: Map<string, IRStateVariable>,
  lines: string[],
): void {
  const arrayVar = eachBlock.arrayVar;
  const listVarName = sanitizeVarName(eachBlock.listNodeId);
  const sv = stateVarMap.get(arrayVar);

  lines.push(`  if m.state.dirty.${arrayVar} then`);
  lines.push('    content = CreateObject("roSGNode", "ContentNode")');
  if (eachBlock.indexName) {
    lines.push("    __idx = 0");
  }
  lines.push(`    for each item in m.state.${arrayVar}`);
  lines.push('      child = content.createChild("ContentNode")');

  // Declare and assign all fields from the array item schema
  if (sv?.arrayItemFields) {
    for (const field of sv.arrayItemFields) {
      lines.push(`      child.addField("${field.name}", "${field.type}", false)`);
    }
    for (const field of sv.arrayItemFields) {
      lines.push(`      child.${field.name} = item.${field.name}`);
    }
  }

  // Index field for {#each items as item, i}
  if (eachBlock.indexName) {
    lines.push('      child.addField("__index", "integer", false)');
    lines.push("      child.__index = __idx");
    lines.push("      __idx = __idx + 1");
  }

  lines.push("    end for");
  lines.push(`    m.${listVarName}.content = content`);
  lines.push("  end if");
}

function emitBindingValue(
  binding: IRBinding,
  stateVarMap: Map<string, IRStateVariable>,
): string {
  if (binding.brsExpression) {
    return binding.brsExpression;
  }

  if (binding.textParts) {
    const parts = binding.textParts.map((part) => {
      if (part.type === "static") {
        return `"${escapeString(part.value)}"`;
      } else {
        const sv = stateVarMap.get(part.value);
        return coerceToString(part.value, sv);
      }
    });
    return parts.join(" + ");
  }

  const sv = stateVarMap.get(binding.stateVar);
  const targetType = FIELD_TYPES[binding.property] ?? "string";

  return coerceValue(binding.stateVar, sv, targetType);
}

function coerceToString(varName: string, sv: IRStateVariable | undefined): string {
  if (!sv || sv.type === "string") {
    return `m.state.${varName}`;
  }
  if (sv.type === "number") {
    return `Str(m.state.${varName}).Trim()`;
  }
  if (sv.type === "boolean") {
    return `Str(m.state.${varName})`;
  }
  return `m.state.${varName}`;
}

function coerceValue(
  varName: string,
  sv: IRStateVariable | undefined,
  targetType: "string" | "number" | "boolean" | "color" | "array",
): string {
  const sourceType = sv?.type ?? "string";

  if (targetType === "string" || targetType === "color") {
    if (sourceType === "number") {
      return `Str(m.state.${varName}).Trim()`;
    }
    if (sourceType === "boolean") {
      return `Str(m.state.${varName})`;
    }
    return `m.state.${varName}`;
  }

  return `m.state.${varName}`;
}

function emitOnKeyEvent(component: IRComponent, lines: string[]): void {
  if (!component.events) return;

  const selectEvents = component.events.filter((e) => e.eventType === "select");
  if (selectEvents.length === 0) return;

  lines.push("function onKeyEvent(key as String, press as Boolean) as Boolean");
  lines.push("  if press then");
  lines.push('    if key = "OK" then');
  lines.push("      focused = m.top.focusedChild");
  lines.push("      if focused <> invalid then");

  for (let i = 0; i < selectEvents.length; i++) {
    const event = selectEvents[i]!;
    const prefix = i === 0 ? "        if" : "        else if";
    lines.push(`${prefix} focused.id = "${event.nodeId}" then`);
    lines.push(`          ${event.handlerName}()`);
    lines.push("          return true");
  }

  lines.push("        end if");
  lines.push("      end if");
  lines.push("    end if");
  lines.push("  end if");
  lines.push("  return false");
  lines.push("end function");
}

function emitHandlers(component: IRComponent, lines: string[]): void {
  if (!component.handlers) return;

  for (let i = 0; i < component.handlers.length; i++) {
    const handler = component.handlers[i]!;
    if (i > 0) lines.push("");
    emitHandler(handler, lines);
  }
}

function emitHandler(handler: IRHandler, lines: string[]): void {
  lines.push(`function ${handler.name}()`);

  emitStatements(handler.statements, lines, 2);

  for (const varName of handler.mutatedVariables) {
    lines.push(`  m.state.dirty.${varName} = true`);
  }

  lines.push("  m_update()");
  lines.push("end function");
}

function emitStatements(stmts: IRHandlerStatement[], lines: string[], indent: number): void {
  const pad = " ".repeat(indent);
  for (const stmt of stmts) {
    switch (stmt.type) {
      case "if": {
        if (stmt.testPreamble) {
          for (const line of stmt.testPreamble) {
            lines.push(`${pad}${line}`);
          }
        }
        lines.push(`${pad}if ${stmt.testBrs} then`);
        emitStatements(stmt.consequent, lines, indent + 2);
        if (stmt.alternate && stmt.alternate.length > 0) {
          // Check if alternate is a single 'if' (else-if chain)
          if (stmt.alternate.length === 1 && stmt.alternate[0]!.type === "if") {
            const elseIf = stmt.alternate[0] as IRHandlerStatement & { type: "if" };
            if (elseIf.testPreamble) {
              for (const line of elseIf.testPreamble) {
                lines.push(`${pad}${line}`);
              }
            }
            lines.push(`${pad}else if ${(elseIf as { testBrs: string }).testBrs} then`);
            emitStatements((elseIf as { consequent: IRHandlerStatement[] }).consequent, lines, indent + 2);
            if ((elseIf as { alternate?: IRHandlerStatement[] }).alternate && (elseIf as { alternate?: IRHandlerStatement[] }).alternate!.length > 0) {
              emitElseChain((elseIf as { alternate?: IRHandlerStatement[] }).alternate!, lines, indent, pad);
            } else {
              lines.push(`${pad}end if`);
            }
          } else {
            lines.push(`${pad}else`);
            emitStatements(stmt.alternate, lines, indent + 2);
            lines.push(`${pad}end if`);
          }
        } else {
          lines.push(`${pad}end if`);
        }
        break;
      }
      case "for-each": {
        if (stmt.iterablePreamble) {
          for (const line of stmt.iterablePreamble) {
            lines.push(`${pad}${line}`);
          }
        }
        lines.push(`${pad}for each ${stmt.variable} in ${stmt.iterableBrs}`);
        emitStatements(stmt.body, lines, indent + 2);
        lines.push(`${pad}end for`);
        break;
      }
      case "while": {
        if (stmt.testPreamble) {
          for (const line of stmt.testPreamble) {
            lines.push(`${pad}${line}`);
          }
        }
        lines.push(`${pad}while ${stmt.testBrs}`);
        emitStatements(stmt.body, lines, indent + 2);
        lines.push(`${pad}end while`);
        break;
      }
      case "try-catch": {
        lines.push(`${pad}try`);
        emitStatements(stmt.tryBody, lines, indent + 2);
        lines.push(`${pad}catch ${stmt.catchVar}`);
        emitStatements(stmt.catchBody, lines, indent + 2);
        lines.push(`${pad}end try`);
        break;
      }
      case "return": {
        if (stmt.valuePreamble) {
          for (const line of stmt.valuePreamble) {
            lines.push(`${pad}${line}`);
          }
        }
        if (stmt.valueBrs) {
          lines.push(`${pad}return ${stmt.valueBrs}`);
        } else {
          lines.push(`${pad}return`);
        }
        break;
      }
      case "var-decl": {
        if (stmt.valuePreamble) {
          for (const line of stmt.valuePreamble) {
            lines.push(`${pad}${line}`);
          }
        }
        lines.push(`${pad}${stmt.variable} = ${stmt.valueBrs}`);
        break;
      }
      default: {
        // Flat statement types — use existing emitStatement
        if ("preamble" in stmt && stmt.preamble) {
          for (const line of stmt.preamble) {
            lines.push(`${pad}${line}`);
          }
        }
        const emitted = emitStatement(stmt);
        if (emitted !== "") {
          lines.push(`${pad}${emitted}`);
        }
        break;
      }
    }
  }
}

function emitElseChain(alternate: IRHandlerStatement[], lines: string[], indent: number, pad: string): void {
  if (alternate.length === 1 && alternate[0]!.type === "if") {
    const elseIf = alternate[0] as IRHandlerStatement & { type: "if" };
    if ((elseIf as { testPreamble?: string[] }).testPreamble) {
      for (const line of (elseIf as { testPreamble?: string[] }).testPreamble!) {
        lines.push(`${pad}${line}`);
      }
    }
    lines.push(`${pad}else if ${(elseIf as { testBrs: string }).testBrs} then`);
    emitStatements((elseIf as { consequent: IRHandlerStatement[] }).consequent, lines, indent + 2);
    if ((elseIf as { alternate?: IRHandlerStatement[] }).alternate && (elseIf as { alternate?: IRHandlerStatement[] }).alternate!.length > 0) {
      emitElseChain((elseIf as { alternate?: IRHandlerStatement[] }).alternate!, lines, indent, pad);
    } else {
      lines.push(`${pad}end if`);
    }
  } else {
    lines.push(`${pad}else`);
    emitStatements(alternate, lines, indent + 2);
    lines.push(`${pad}end if`);
  }
}

function emitExtractedCallbacks(component: IRComponent, lines: string[]): void {
  if (!component.extractedCallbacks) return;

  for (const handler of component.extractedCallbacks) {
    lines.push("");
    emitHandler(handler, lines);
  }
}

function emitStatement(stmt: IRHandlerStatement): string {
  switch (stmt.type) {
    case "increment":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + 1`;
    case "decrement":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - 1`;
    case "assign-literal":
      return `m.state.${stmt.variable} = ${formatLiteral(stmt.value)}`;
    case "assign-negate":
      return `m.state.${stmt.variable} = not m.state.${stmt.variable}`;
    case "assign-add":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + ${formatLiteral(stmt.operand)}`;
    case "assign-sub":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - ${formatLiteral(stmt.operand)}`;
    case "assign-expr":
      return `m.state.${stmt.variable} = ${stmt.brsCode}`;
    case "expr-statement":
      return stmt.brsCode;
    default:
      return `' unsupported statement type`;
  }
}

function formatLiteral(value: string): string {
  const num = Number(value);
  if (!isNaN(num) && value !== "" && value !== "true" && value !== "false") {
    return value;
  }
  if (value === "true" || value === "false") {
    return value;
  }
  return `"${escapeString(value)}"`;
}

function emitPropObserver(component: IRComponent, lines: string[]): void {
  if (!component.props) return;

  lines.push("");
  lines.push("sub onPropChanged()");
  for (const prop of component.props) {
    lines.push(`  m.state.${prop.name} = m.top.${prop.name}`);
    lines.push(`  m.state.dirty.${prop.name} = true`);
  }
  lines.push("  m_update()");
  lines.push("end sub");
}

function emitTwoWayObservers(component: IRComponent, lines: string[]): void {
  if (!component.twoWayBindings) return;

  for (const twb of component.twoWayBindings) {
    const varName = sanitizeVarName(twb.nodeId);
    lines.push("");
    lines.push(`sub on_${varName}_changed()`);
    lines.push(`  m.state.${twb.stateVar} = m.${varName}.text`);
    lines.push(`  m.state.dirty.${twb.stateVar} = true`);
    lines.push("  m_update()");
    lines.push("end sub");
  }
}

function emitAsyncHandlers(component: IRComponent, lines: string[]): void {
  if (!component.asyncHandlers) return;

  for (const handler of component.asyncHandlers) {
    // Emit main sub (pre-await statements + kickoff)
    lines.push("");
    lines.push(`sub ${handler.name}()`);
    emitStatements(handler.statements, lines, 2);

    // Kickoff first continuation
    if (handler.continuations.length > 0) {
      const first = handler.continuations[0]!;
      emitAsyncKickoff(first, 0, lines);
    }

    lines.push("end sub");

    // Emit each continuation sub
    for (let i = 0; i < handler.continuations.length; i++) {
      const cont = handler.continuations[i]!;
      const nextCont = handler.continuations[i + 1];

      lines.push("");
      if (cont.awaitType === "generic") {
        lines.push(`sub ${cont.name}(data as Dynamic)`);
      } else {
        lines.push(`sub ${cont.name}()`);
      }

      // Get the result from the previous await
      if (cont.resultVar) {
        if (cont.awaitType === "fetch") {
          lines.push(`  ${cont.resultVar} = m.${cont.awaitTarget}.response`);
        } else {
          lines.push(`  ${cont.resultVar} = data`);
        }
      }

      // Emit continuation body
      emitStatements(cont.statements, lines, 2);

      // Kickoff next continuation if present
      if (nextCont) {
        emitAsyncKickoff(nextCont, i + 1, lines);
      }

      // Dirty flags and update for mutations
      for (const v of cont.mutatedVariables) {
        lines.push(`  m.state.dirty.${v} = true`);
      }
      if (cont.mutatedVariables.length > 0) {
        lines.push("  m_update()");
      }

      lines.push("end sub");
    }
  }
}

function emitAsyncKickoff(cont: { awaitType: string; awaitTarget: string; fetchUrl?: string; name: string }, idx: number, lines: string[]): void {
  if (cont.awaitType === "fetch" && cont.fetchUrl) {
    lines.push(`  m.${cont.awaitTarget} = fetch(${cont.fetchUrl})`);
    lines.push(`  m.${cont.awaitTarget}.observeField("response", "${cont.name}")`);
  } else {
    lines.push(`  __promise_${idx} = ${cont.awaitTarget}`);
    lines.push(`  Promise_then(__promise_${idx}, "${cont.name}")`);
  }
}

function emitFetchCallbacks(component: IRComponent, lines: string[]): void {
  if (!component.state) return;

  for (const sv of component.state) {
    if (sv.fetchCall) {
      lines.push("");
      lines.push(`function on_${sv.name}_loaded()`);
      lines.push(`  data = ParseJSON(m.fetchTask_${sv.name}.response)`);
      lines.push("  if data <> invalid then");
      lines.push(`    m.state.${sv.name} = data`);
      lines.push(`    m.state.dirty.${sv.name} = true`);
      lines.push("    m_update()");
      lines.push("  end if");
      lines.push("end function");
    }
  }
}

function formatStateInitialValue(sv: IRStateVariable): string {
  if (sv.type === "number") return sv.initialValue;
  if (sv.type === "boolean") return sv.initialValue;
  if (sv.type === "array") {
    if (sv.fetchCall) return "[]";
    return formatArrayLiteral(sv);
  }
  if (sv.type === "object") {
    return formatObjectLiteral(sv);
  }
  return `"${escapeString(sv.initialValue)}"`;
}

function formatObjectLiteral(sv: IRStateVariable): string {
  if (!sv.objectFields || sv.objectFields.length === 0) return "{}";

  const entries = sv.objectFields.map((field) => {
    if (field.type === "number") return `${field.name}: ${field.value}`;
    if (field.type === "boolean") return `${field.name}: ${field.value}`;
    return `${field.name}: "${escapeString(field.value)}"`;
  });

  return `{ ${entries.join(", ")} }`;
}

function formatArrayLiteral(sv: IRStateVariable): string {
  if (!sv.arrayItems || !sv.arrayItemFields) return "[]";

  const items = sv.arrayItems.map((item) => {
    const entries = sv.arrayItemFields!.map((field) => {
      const value = item.fields[field.name] ?? "";
      if (field.type === "number") return `${field.name}: ${value}`;
      if (field.type === "boolean") return `${field.name}: ${value}`;
      return `${field.name}: "${escapeString(value)}"`;
    });
    return `{ ${entries.join(", ")} }`;
  });

  return `[${items.join(", ")}]`;
}

function escapeString(s: string): string {
  return s.replace(/"/g, '""');
}

interface NodeRef {
  id: string;
  varName: string;
  properties: Array<{ name: string; value: string }>;
}

function collectDynamicNodeRefs(nodes: IRNode[]): NodeRef[] {
  const refs: NodeRef[] = [];

  function traverse(node: IRNode): void {
    const dynamicProps = node.properties.filter((p) => p.dynamic);
    if (dynamicProps.length > 0) {
      refs.push({
        id: node.id,
        varName: sanitizeVarName(node.id),
        properties: dynamicProps,
      });
    }
    for (const child of node.children) {
      traverse(child);
    }
  }

  for (const node of nodes) {
    traverse(node);
  }

  return refs;
}

function sanitizeVarName(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

export function toBrightScriptValue(fieldName: string, value: string): string {
  if (value === "true" || value === "false") {
    return value;
  }

  if (value.startsWith("0x")) {
    return `"${value}"`;
  }

  // Array fields: translation=[x,y], scale=[x,y]
  const arrayMatch = value.match(/^\[(.+)\]$/);
  if (arrayMatch && FIELD_TYPES[fieldName] === "array") {
    return `[${arrayMatch[1]}]`;
  }

  const numericFields = new Set([
    "width",
    "height",
    "fontSize",
    "opacity",
    "rotation",
    "lineSpacing",
    "letterSpacing",
    "maxLines",
  ]);
  if (numericFields.has(fieldName)) {
    const num = parseFloat(value);
    if (!isNaN(num)) {
      return String(num);
    }
  }

  return `"${value.replace(/"/g, '""')}"`;
}
