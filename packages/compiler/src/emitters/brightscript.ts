import type { IRComponent, IRNode } from "../ir/types.js";

export function emitBrightScript(component: IRComponent): string {
  const lines: string[] = [];

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.1");
  lines.push("");
  lines.push("function init()");

  // Only emit findNode refs and assignments for dynamic properties.
  // Static properties are set in XML attributes â€” no duplication.
  const nodeRefs = collectDynamicNodeRefs(component.children);

  if (nodeRefs.length > 0) {
    lines.push("  ' node refs");
    for (const ref of nodeRefs) {
      lines.push(`  m.${ref.varName} = m.top.findNode("${ref.id}")`);
    }
    lines.push("");

    lines.push("  ' dynamic properties");
    for (const ref of nodeRefs) {
      for (const prop of ref.properties) {
        const bsValue = toBrightScriptValue(prop.name, prop.value);
        lines.push(`  m.${ref.varName}.${prop.name} = ${bsValue}`);
      }
    }
  }

  lines.push("end function");

  return lines.join("\n");
}

interface NodeRef {
  id: string;
  varName: string;
  properties: Array<{ name: string; value: string }>;
}

function collectDynamicNodeRefs(nodes: IRNode[]): NodeRef[] {
  const refs: NodeRef[] = [];

  function traverse(node: IRNode): void {
    const dynamicProps = node.properties.filter((p) => p.dynamic);
    if (dynamicProps.length > 0) {
      refs.push({
        id: node.id,
        varName: sanitizeVarName(node.id),
        properties: dynamicProps,
      });
    }
    for (const child of node.children) {
      traverse(child);
    }
  }

  for (const node of nodes) {
    traverse(node);
  }

  return refs;
}

function sanitizeVarName(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

export function toBrightScriptValue(fieldName: string, value: string): string {
  if (value === "true" || value === "false") {
    return value;
  }

  if (value.startsWith("0x")) {
    return `"${value}"`;
  }

  const numericFields = new Set([
    "width",
    "height",
    "fontSize",
    "opacity",
  ]);
  if (numericFields.has(fieldName)) {
    const num = parseFloat(value);
    if (!isNaN(num)) {
      return String(num);
    }
  }

  return `"${value.replace(/"/g, '""')}"`;
}
