import MagicString from "magic-string";
import type {
  IRComponent,
  IRNode,
  IRBinding,
  IRHandler,
  IRHandlerStatement,
  IRStateVariable,
  IRItemComponent,
  IREachBlock,
} from "../ir/types.js";

const FIELD_TYPES: Record<string, "string" | "number" | "boolean" | "color"> = {
  text: "string",
  width: "number",
  height: "number",
  fontSize: "number",
  opacity: "number",
  color: "string",
  visible: "boolean",
  focusable: "boolean",
  uri: "string",
};

/**
 * Build BrightScript output using MagicString.
 * Internally uses MagicString so we can add source map generation later
 * via ms.generateMap() without changing the emitter internals.
 */
export function emitBrightScript(component: IRComponent): string {
  const hasState = component.state && component.state.length > 0;

  if (!hasState) {
    return emitV1(component);
  }

  const lines: string[] = [];
  buildV2(component, lines);

  // Use MagicString as the output buffer — ready for .generateMap() later
  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

export function emitItemComponentBrightScript(itemComp: IRItemComponent): string {
  const lines: string[] = [];

  lines.push(`' ${itemComp.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");

  // init() — find all nodes
  lines.push("function init()");
  const nodeIds = new Set<string>();
  for (const binding of itemComp.fieldBindings) {
    nodeIds.add(binding.nodeId);
  }
  for (const nodeId of nodeIds) {
    const varName = sanitizeVarName(nodeId);
    lines.push(`  m.${varName} = m.top.findNode("${nodeId}")`);
  }
  lines.push("end function");
  lines.push("");

  // onItemContentChanged()
  lines.push("function onItemContentChanged()");
  lines.push("  itemContent = m.top.itemContent");
  lines.push("  if itemContent <> invalid then");

  for (const binding of itemComp.fieldBindings) {
    const varName = sanitizeVarName(binding.nodeId);
    if (binding.textParts && binding.textParts.length > 1) {
      // Mixed text concatenation
      const parts = binding.textParts.map((part) => {
        if (part.type === "static") {
          return `"${escapeString(part.value)}"`;
        } else {
          return `itemContent.${part.value}`;
        }
      });
      lines.push(`    m.${varName}.${binding.property} = ${parts.join(" + ")}`);
    } else {
      // Simple field binding
      lines.push(`    m.${varName}.${binding.property} = itemContent.${binding.field}`);
    }
  }

  lines.push("  end if");
  lines.push("end function");

  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function buildV2(component: IRComponent, lines: string[]): void {
  const hasBindings = component.bindings && component.bindings.length > 0;
  const hasEvents = component.events && component.events.length > 0;
  const hasHandlers = component.handlers && component.handlers.length > 0;
  const hasEachBlocks = component.eachBlocks && component.eachBlocks.length > 0;

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");

  emitInit(component, lines);
  lines.push("");

  if (hasBindings || hasEachBlocks) {
    emitUpdate(component, lines);
    lines.push("");
  }

  if (hasEvents) {
    emitOnKeyEvent(component, lines);
    lines.push("");
  }

  if (hasHandlers) {
    emitHandlers(component, lines);
  }

  if (component.extractedCallbacks && component.extractedCallbacks.length > 0) {
    emitExtractedCallbacks(component, lines);
  }

  emitFetchCallbacks(component, lines);

  while (lines[lines.length - 1] === "") {
    lines.pop();
  }
}

function emitV1(component: IRComponent): string {
  const lines: string[] = [];

  lines.push(`' ${component.name}.brs`);
  lines.push("' Generated by svelte-roku compiler v0.6");
  lines.push("");
  lines.push("function init()");

  const nodeRefs = collectDynamicNodeRefs(component.children);

  if (nodeRefs.length > 0) {
    lines.push("  ' node refs");
    for (const ref of nodeRefs) {
      lines.push(`  m.${ref.varName} = m.top.findNode("${ref.id}")`);
    }
    lines.push("");

    lines.push("  ' dynamic properties");
    for (const ref of nodeRefs) {
      for (const prop of ref.properties) {
        const bsValue = toBrightScriptValue(prop.name, prop.value);
        lines.push(`  m.${ref.varName}.${prop.name} = ${bsValue}`);
      }
    }
  }

  lines.push("end function");

  const ms = new MagicString(lines.join("\n"));
  return ms.toString();
}

function emitInit(component: IRComponent, lines: string[]): void {
  lines.push("function init()");

  const refNodeIds = new Set<string>();
  if (component.bindings) {
    for (const b of component.bindings) {
      refNodeIds.add(b.nodeId);
    }
  }
  if (component.events) {
    for (const e of component.events) {
      refNodeIds.add(e.nodeId);
    }
  }
  // Also add MarkupList node refs for eachBlocks
  if (component.eachBlocks) {
    for (const eb of component.eachBlocks) {
      refNodeIds.add(eb.listNodeId);
    }
  }

  if (refNodeIds.size > 0) {
    for (const nodeId of refNodeIds) {
      const varName = sanitizeVarName(nodeId);
      lines.push(`  m.${varName} = m.top.findNode("${nodeId}")`);
    }
  }

  if (component.state && component.state.length > 0) {
    const stateEntries = component.state.map((sv) => {
      return `${sv.name}: ${formatStateInitialValue(sv)}`;
    });
    const dirtyEntries = component.state.map((sv) => `${sv.name}: true`);
    lines.push(`  m.state = { ${stateEntries.join(", ")}, dirty: { ${dirtyEntries.join(", ")} } }`);
  }

  if (component.autofocusNodeId) {
    const varName = sanitizeVarName(component.autofocusNodeId);
    lines.push(`  m.${varName}.setFocus(true)`);
  }

  // Fetch calls via runtime
  if (component.state) {
    for (const sv of component.state) {
      if (sv.fetchCall) {
        const urlArg = sv.fetchCall.urlIsLiteral ? `"${sv.fetchCall.url}"` : sv.fetchCall.url;
        const optionsArg = sv.fetchCall.optionsSource ?? "{}";
        lines.push(`  m.fetchTask_${sv.name} = fetch(${urlArg}, ${optionsArg})`);
        lines.push(`  m.fetchTask_${sv.name}.observeField("response", "on_${sv.name}_loaded")`);
      }
    }
  }

  const hasBindings = component.bindings && component.bindings.length > 0;
  const hasEachBlocks = component.eachBlocks && component.eachBlocks.length > 0;
  if (hasBindings || hasEachBlocks) {
    lines.push("  m_update()");
  }

  lines.push("end function");
}

function emitUpdate(component: IRComponent, lines: string[]): void {
  if (!component.state) return;

  lines.push("function m_update()");

  const stateVarMap = new Map<string, IRStateVariable>();
  for (const sv of component.state) {
    stateVarMap.set(sv.name, sv);
  }

  // Emit binding updates
  if (component.bindings && component.bindings.length > 0) {
    const groups = new Map<string, IRBinding[]>();
    for (const binding of component.bindings) {
      const key = [...binding.dependencies].sort().join(",");
      const group = groups.get(key) ?? [];
      group.push(binding);
      groups.set(key, group);
    }

    for (const [, bindings] of groups) {
      const deps = bindings[0]!.dependencies;
      const condition = deps
        .map((d) => `m.state.dirty.${d}`)
        .join(" or ");

      lines.push(`  if ${condition} then`);

      for (const binding of bindings) {
        const varName = sanitizeVarName(binding.nodeId);
        const value = emitBindingValue(binding, stateVarMap);
        lines.push(`    m.${varName}.${binding.property} = ${value}`);
      }

      lines.push("  end if");
    }
  }

  // Emit ContentNode creation for eachBlocks
  if (component.eachBlocks && component.eachBlocks.length > 0) {
    for (const eachBlock of component.eachBlocks) {
      emitContentNodeCreation(eachBlock, stateVarMap, lines);
    }
  }

  lines.push("  m.state.dirty = {}");
  lines.push("end function");
}

function emitContentNodeCreation(
  eachBlock: IREachBlock,
  stateVarMap: Map<string, IRStateVariable>,
  lines: string[],
): void {
  const arrayVar = eachBlock.arrayVar;
  const listVarName = sanitizeVarName(eachBlock.listNodeId);
  const sv = stateVarMap.get(arrayVar);

  lines.push(`  if m.state.dirty.${arrayVar} then`);
  lines.push('    content = CreateObject("roSGNode", "ContentNode")');
  lines.push(`    for each item in m.state.${arrayVar}`);
  lines.push('      child = content.createChild("ContentNode")');

  // Declare and assign all fields from the array item schema
  if (sv?.arrayItemFields) {
    for (const field of sv.arrayItemFields) {
      lines.push(`      child.addField("${field.name}", "${field.type}", false)`);
    }
    for (const field of sv.arrayItemFields) {
      lines.push(`      child.${field.name} = item.${field.name}`);
    }
  }

  lines.push("    end for");
  lines.push(`    m.${listVarName}.content = content`);
  lines.push("  end if");
}

function emitBindingValue(
  binding: IRBinding,
  stateVarMap: Map<string, IRStateVariable>,
): string {
  if (binding.brsExpression) {
    return binding.brsExpression;
  }

  if (binding.textParts) {
    const parts = binding.textParts.map((part) => {
      if (part.type === "static") {
        return `"${escapeString(part.value)}"`;
      } else {
        const sv = stateVarMap.get(part.value);
        return coerceToString(part.value, sv);
      }
    });
    return parts.join(" + ");
  }

  const sv = stateVarMap.get(binding.stateVar);
  const targetType = FIELD_TYPES[binding.property] ?? "string";

  return coerceValue(binding.stateVar, sv, targetType);
}

function coerceToString(varName: string, sv: IRStateVariable | undefined): string {
  if (!sv || sv.type === "string") {
    return `m.state.${varName}`;
  }
  if (sv.type === "number") {
    return `Str(m.state.${varName}).Trim()`;
  }
  if (sv.type === "boolean") {
    return `Str(m.state.${varName})`;
  }
  return `m.state.${varName}`;
}

function coerceValue(
  varName: string,
  sv: IRStateVariable | undefined,
  targetType: "string" | "number" | "boolean" | "color",
): string {
  const sourceType = sv?.type ?? "string";

  if (targetType === "string" || targetType === "color") {
    if (sourceType === "number") {
      return `Str(m.state.${varName}).Trim()`;
    }
    if (sourceType === "boolean") {
      return `Str(m.state.${varName})`;
    }
    return `m.state.${varName}`;
  }

  return `m.state.${varName}`;
}

function emitOnKeyEvent(component: IRComponent, lines: string[]): void {
  if (!component.events) return;

  const selectEvents = component.events.filter((e) => e.eventType === "select");
  if (selectEvents.length === 0) return;

  lines.push("function onKeyEvent(key as String, press as Boolean) as Boolean");
  lines.push("  if press then");
  lines.push('    if key = "OK" then');
  lines.push("      focused = m.top.focusedChild");
  lines.push("      if focused <> invalid then");

  for (let i = 0; i < selectEvents.length; i++) {
    const event = selectEvents[i]!;
    const prefix = i === 0 ? "        if" : "        else if";
    lines.push(`${prefix} focused.id = "${event.nodeId}" then`);
    lines.push(`          ${event.handlerName}()`);
    lines.push("          return true");
  }

  lines.push("        end if");
  lines.push("      end if");
  lines.push("    end if");
  lines.push("  end if");
  lines.push("  return false");
  lines.push("end function");
}

function emitHandlers(component: IRComponent, lines: string[]): void {
  if (!component.handlers) return;

  for (let i = 0; i < component.handlers.length; i++) {
    const handler = component.handlers[i]!;
    if (i > 0) lines.push("");
    emitHandler(handler, lines);
  }
}

function emitHandler(handler: IRHandler, lines: string[]): void {
  lines.push(`function ${handler.name}()`);

  for (const stmt of handler.statements) {
    if ("preamble" in stmt && stmt.preamble) {
      for (const line of stmt.preamble) {
        lines.push(`  ${line}`);
      }
    }
    const emitted = emitStatement(stmt);
    if (emitted !== "") {
      lines.push(`  ${emitted}`);
    }
  }

  for (const varName of handler.mutatedVariables) {
    lines.push(`  m.state.dirty.${varName} = true`);
  }

  lines.push("  m_update()");
  lines.push("end function");
}

function emitExtractedCallbacks(component: IRComponent, lines: string[]): void {
  if (!component.extractedCallbacks) return;

  for (const handler of component.extractedCallbacks) {
    lines.push("");
    emitHandler(handler, lines);
  }
}

function emitStatement(stmt: IRHandlerStatement): string {
  switch (stmt.type) {
    case "increment":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + 1`;
    case "decrement":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - 1`;
    case "assign-literal":
      return `m.state.${stmt.variable} = ${formatLiteral(stmt.value)}`;
    case "assign-negate":
      return `m.state.${stmt.variable} = not m.state.${stmt.variable}`;
    case "assign-add":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} + ${formatLiteral(stmt.operand)}`;
    case "assign-sub":
      return `m.state.${stmt.variable} = m.state.${stmt.variable} - ${formatLiteral(stmt.operand)}`;
    case "assign-expr":
      return `m.state.${stmt.variable} = ${stmt.brsCode}`;
    case "expr-statement":
      return stmt.brsCode;
  }
}

function formatLiteral(value: string): string {
  const num = Number(value);
  if (!isNaN(num) && value !== "" && value !== "true" && value !== "false") {
    return value;
  }
  if (value === "true" || value === "false") {
    return value;
  }
  return `"${escapeString(value)}"`;
}

function emitFetchCallbacks(component: IRComponent, lines: string[]): void {
  if (!component.state) return;

  for (const sv of component.state) {
    if (sv.fetchCall) {
      lines.push("");
      lines.push(`function on_${sv.name}_loaded()`);
      lines.push(`  data = ParseJSON(m.fetchTask_${sv.name}.response)`);
      lines.push("  if data <> invalid then");
      lines.push(`    m.state.${sv.name} = data`);
      lines.push(`    m.state.dirty.${sv.name} = true`);
      lines.push("    m_update()");
      lines.push("  end if");
      lines.push("end function");
    }
  }
}

function formatStateInitialValue(sv: IRStateVariable): string {
  if (sv.type === "number") return sv.initialValue;
  if (sv.type === "boolean") return sv.initialValue;
  if (sv.type === "array") {
    if (sv.fetchCall) return "[]";
    return formatArrayLiteral(sv);
  }
  return `"${escapeString(sv.initialValue)}"`;
}

function formatArrayLiteral(sv: IRStateVariable): string {
  if (!sv.arrayItems || !sv.arrayItemFields) return "[]";

  const items = sv.arrayItems.map((item) => {
    const entries = sv.arrayItemFields!.map((field) => {
      const value = item.fields[field.name] ?? "";
      if (field.type === "number") return `${field.name}: ${value}`;
      if (field.type === "boolean") return `${field.name}: ${value}`;
      return `${field.name}: "${escapeString(value)}"`;
    });
    return `{ ${entries.join(", ")} }`;
  });

  return `[${items.join(", ")}]`;
}

function escapeString(s: string): string {
  return s.replace(/"/g, '""');
}

interface NodeRef {
  id: string;
  varName: string;
  properties: Array<{ name: string; value: string }>;
}

function collectDynamicNodeRefs(nodes: IRNode[]): NodeRef[] {
  const refs: NodeRef[] = [];

  function traverse(node: IRNode): void {
    const dynamicProps = node.properties.filter((p) => p.dynamic);
    if (dynamicProps.length > 0) {
      refs.push({
        id: node.id,
        varName: sanitizeVarName(node.id),
        properties: dynamicProps,
      });
    }
    for (const child of node.children) {
      traverse(child);
    }
  }

  for (const node of nodes) {
    traverse(node);
  }

  return refs;
}

function sanitizeVarName(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

export function toBrightScriptValue(fieldName: string, value: string): string {
  if (value === "true" || value === "false") {
    return value;
  }

  if (value.startsWith("0x")) {
    return `"${value}"`;
  }

  const numericFields = new Set([
    "width",
    "height",
    "fontSize",
    "opacity",
  ]);
  if (numericFields.has(fieldName)) {
    const num = parseFloat(value);
    if (!isNaN(num)) {
      return String(num);
    }
  }

  return `"${value.replace(/"/g, '""')}"`;
}
